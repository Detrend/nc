#pragma once

#include <engine/graphics/resources/model.h>

#include <cstdint>

namespace nc
{
 //==============================================================================
template<ResLifetime lifetime>
inline ModelHandle ModelManager::add(const Mesh& mesh, const Material& material)
{
  auto& storage = get_storage<lifetime>();
  const u32 id = static_cast<u32>(storage.size());

  storage.emplace_back(mesh, material);
  return ModelHandle(id, lifetime, ModelManager::generation);
}

//==============================================================================
template<ResLifetime lifetime>
inline void ModelManager::unload()
{
  auto& storage = get_storage<lifetime>();
  storage.clear();

  if constexpr (lifetime == ResLifetime::Level)
  {
    ModelManager::generation++;
  }
}

//==============================================================================
template<ResLifetime lifetime>
inline std::vector<Model>& ModelManager::get_storage()
{
  static_assert(lifetime == ResLifetime::Level || lifetime == ResLifetime::Game);

  if constexpr (lifetime == ResLifetime::Level)
  {
    return m_level_models;
  }
  else
  {
    return m_game_models;
  }
}

}

//==============================================================================
namespace std
{

inline std::size_t hash<nc::ModelHandle>::operator()(const nc::ModelHandle& handle) const
{
  // hash_combine lambda was generated by deepseek ai
  auto hash_combine = []<typename T>(std::size_t& seed, const T& value)
  {
    std::hash<T> hasher;
    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
  };

  std::size_t seed = 0;
  hash_combine(seed, handle.m_model_id);
  hash_combine(seed, handle.m_lifetime);
  return seed;
}

}
