#include <engine/graphics/resources/mesh.h>
#include <common.h>

#include <glad/glad.h>

#include <vector>

namespace nc
{

//==============================================================================
// Vertex data for cube mesh. Generated by deepseek ai.
constexpr f32 cube_vertices[] =
{
  // Positions          // Normals
  // Front face
  -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Bottom-left
   0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Bottom-right
   0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Top-right
   0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Top-right
  -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Top-left
  -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f, // Bottom-left

  // Back face
  -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Bottom-left
   0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Top-right
   0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Bottom-right
   0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Top-right
  -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Bottom-left
  -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, // Top-left

  // Left face
  -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f, // Top-front
  -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f, // Bottom-back
  -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f, // Bottom-front
  -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f, // Bottom-back
  -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f, // Top-front
  -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f, // Top-back

  // Right face
   0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f, // Bottom-front
   0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f, // Bottom-back
   0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f, // Top-front
   0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f, // Top-back
   0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f, // Top-front
   0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f, // Bottom-back

  // Top face
  -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f, // Back-left
   0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f, // Front-right
   0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f, // Back-right
   0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f, // Front-right
  -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f, // Back-left
  -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f, // Front-left

  // Bottom face
  -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f, // Back-left
   0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f, // Back-right
   0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f, // Front-right
   0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f, // Front-right
  -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f, // Front-left
  -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f  // Back-left
};

//==============================================================================
GLuint Mesh::get_vao() const
{
  return m_vao;
}

//==============================================================================
GLuint Mesh::get_vbo() const
{
  return m_vbo;
}

//==============================================================================
u32 Mesh::get_vertex_count() const
{
  return m_vertex_count;
}

//==============================================================================
GLenum Mesh::get_draw_mode() const
{
  return m_draw_mode;
}

//==============================================================================
bool Mesh::is_valid() const
{
  if (m_lifetime == ResLifetime::Game && m_generation != MeshManager::generation)
  {
    return false;
  }

  return m_vao != 0 && m_vbo != 0 && m_vertex_count != 0 && m_lifetime != ResLifetime::None;
}

//==============================================================================
Mesh::operator bool() const
{
  return this->is_valid();
}

//==============================================================================
Mesh Mesh::invalid()
{
    return Mesh();
}

//==============================================================================
void MeshManager::init()
{
  m_cube_mesh = this->create(ResLifetime::Game, cube_vertices, sizeof(cube_vertices) / sizeof(f32));
}

//==============================================================================
Mesh MeshManager::create(ResLifetime lifetime, const f32* data, u32 count, GLenum draw_mode)
{
  Mesh mesh;
  mesh.m_lifetime = lifetime;
  mesh.m_generation = MeshManager::generation;
  mesh.m_draw_mode = draw_mode;
  mesh.m_vertex_count = count / 6; // 3 floats per position + 3 floats per normal

  // generate buffers
  glGenVertexArrays(1, &mesh.m_vao);
  glGenBuffers(1, &mesh.m_vbo);

  // setup vao
  glBindVertexArray(mesh.m_vao);
  // vertex buffer
  glBindBuffer(GL_ARRAY_BUFFER, mesh.m_vbo);
  glBufferData(GL_ARRAY_BUFFER, count * sizeof(f32), data, GL_STATIC_DRAW);
  //position attribute
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(f32), reinterpret_cast<void*>(0));
  glEnableVertexAttribArray(0);
  // normal attribute
  glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(f32), reinterpret_cast<void*>(3 * sizeof(f32)));
  glEnableVertexAttribArray(1);

  // store created mesh
  auto& storage = this->get_storage(lifetime);
  storage.push_back(mesh);

  return mesh;
}

//==============================================================================
void MeshManager::unload(ResLifetime lifetime)
{
  auto& storage = this->get_storage(lifetime);
  std::vector<GLuint> vao_to_delete;
  std::vector<GLuint> vbo_to_delete;

  for (auto& mesh : storage)
  {
    if (mesh.m_vao != 0)
    {
      vao_to_delete.push_back(mesh.m_vao);
      mesh.m_vao = 0;
    }

    if (mesh.m_vbo != 0)
    {
      vbo_to_delete.push_back(mesh.m_vbo);
      mesh.m_vbo = 0;
    }
  }

  glDeleteVertexArrays(static_cast<GLsizei>(vao_to_delete.size()), vao_to_delete.data());
  glDeleteBuffers(static_cast<GLsizei>(vbo_to_delete.size()), vbo_to_delete.data());
  storage.clear();

  if (lifetime == ResLifetime::Game)
  {
    MeshManager::generation++;
  }
}

//==============================================================================
Mesh MeshManager::get_cube() const
{
  return m_cube_mesh;
}

//==============================================================================
std::vector<Mesh>& MeshManager::get_storage(ResLifetime lifetime)
{
  NC_ASSERT(lifetime == ResLifetime::Game || lifetime == ResLifetime::Level);

  if (lifetime == ResLifetime::Level)
  {
    return m_level_meshes;
  }
  else
  {
    return m_game_meshes;
  }
}

}
