constexpr const char* COMPUTE_SOURCE = R"(

#version 430 core

#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16

#define MAX_LIGHTS_PER_TILE 512

layout (local_size_x = TILE_SIZE_X, local_size_y = TILE_SIZE_Y, local_size_z = 1) in;

struct PointLight
{
    vec3  position;
    float intensity;
    vec3  color;
    float constant;
    float linear;
    float quadratic;
};

struct TileData
{
    uint count;
    uint offset;
};

layout(location = 0) uniform mat4 view;
layout(location = 1) uniform mat4 inv_projection;
layout(location = 2) uniform vec2 window_size;
layout(location = 3) uniform float far_plane;
layout(location = 4) uniform uint num_lights;

layout(std430, binding = 0) readonly buffer light_buffer { PointLight lights[]; };
layout(std430, binding = 1) writeonly buffer light_index_buffer { uint indices[]; };
layout(std430, binding = 2) writeonly buffer tile_data_buffer { TileData tile_data[]; };
layout(std430, binding = 3) buffer light_index_counter_buffer { uint light_index_counter; };

shared uint shared_visible_light_indices[MAX_LIGHTS_PER_TILE];
shared uint shared_light_count;
shared vec4 frustum_planes[4];

float calculate_light_radius(PointLight light)
{
  float max_color = max(light.color.r, max(light.color.g, light.color.b));
  float min_intensity = 256.0f;
  float k = max_color * light.intensity * min_intensity;

  if (light.quadratic < 0.0001)
    return (k - light.constant) / light.linear;

  float discriminant = light.linear * light.linear - 4 * light.quadratic * (light.constant - k);
  if (discriminant < 0)
    return 0;

  return (-light.linear + sqrt(discriminant)) / (2.0 * light.quadratic);
}

float get_signed_distance_to_plane(vec3 point, vec4 plane)
{
  return dot(plane.xyz, point) + plane.w;
}

void main()
{
  uvec2 tile_ID = gl_WorkGroupID.xy;
  uint local_thread_idx = gl_LocalInvocationIndex;

  if (local_thread_idx == 0)
  {
    shared_light_count = 0;

    vec2 tile_min_screen = vec2(tile_ID * uvec2(TILE_SIZE_X, TILE_SIZE_Y));
    vec2 tile_max_screen = vec2((tile_ID + uvec2(1, 1)) * uvec2(TILE_SIZE_X, TILE_SIZE_Y));
    vec2 tile_min_NDC = (tile_min_screen / window_size) * 2.0 - 1.0;
    vec2 tile_max_NDC = (tile_max_screen / window_size) * 2.0 - 1.0;
        
    vec4 p0 = inv_projection * vec4(tile_min_NDC.x, tile_min_NDC.y, -1.0, 1.0);
    vec4 p1 = inv_projection * vec4(tile_max_NDC.x, tile_min_NDC.y, -1.0, 1.0);
    vec4 p2 = inv_projection * vec4(tile_min_NDC.x, tile_max_NDC.y, -1.0, 1.0);
    vec4 p3 = inv_projection * vec4(tile_max_NDC.x, tile_max_NDC.y, -1.0, 1.0);

    vec3 v0 = p0.xyz / p0.w; vec3 v1 = p1.xyz / p1.w;
    vec3 v2 = p2.xyz / p2.w; vec3 v3 = p3.xyz / p3.w;

    frustum_planes[0] = vec4(normalize(cross(v2, v0)), 0.0); // Left
    frustum_planes[1] = vec4(normalize(cross(v1, v3)), 0.0); // Right
    frustum_planes[2] = vec4(normalize(cross(v0, v1)), 0.0); // Bottom
    frustum_planes[3] = vec4(normalize(cross(v3, v2)), 0.0); // Top
  }

  barrier();

  uint global_thread_idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  uint thread_count = gl_NumWorkGroups.x * gl_NumWorkGroups.y * TILE_SIZE_X * TILE_SIZE_Y;

  for (uint light_idx = global_thread_idx; light_idx < num_lights; light_idx += thread_count)
  {
    PointLight light = lights[light_idx];
        
    vec3 pos_view = (view * vec4(light.position, 1.0)).xyz;
    float radius = calculate_light_radius(light);

    // Frustum culling check
    bool is_visible = true;
    for (int i = 0; i < 4; ++i)
    {
        if (get_signed_distance_to_plane(pos_view, frustum_planes[i]) > radius)
        {
            is_visible = false;
            break;
        }
    }
    if (!is_visible)
        continue;
    if ((-pos_view.z - far_plane) > radius)
        continue;
    if ((-pos_view.z + radius) < 0.0)
        continue;
        
    uint storage_idx = atomicAdd(shared_light_count, 1);
    if (storage_idx < MAX_LIGHTS_PER_TILE)
    {
        shared_visible_light_indices[storage_idx] = light_idx;
    }
  }

  barrier();

  if (local_thread_idx == 0)
  {
    uint offset = atomicAdd(light_index_counter, shared_light_count);
        
    uint tile_idx = tile_ID.y * gl_NumWorkGroups.x + tile_ID.x;
    tile_data[tile_idx].count = shared_light_count;
    tile_data[tile_idx].offset = offset;
        
    for (uint i = 0; i < shared_light_count; ++i)
    {
      indices[offset + i] = shared_visible_light_indices[i];
    }
  }
}

)";