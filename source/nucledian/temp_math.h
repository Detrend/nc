// Project Nucledian Source File
#pragma once

#include <types.h>
#include <vec.h>
#include <vector_maths.h>
#include <math.h>

#include <glm/glm.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/constants.hpp>

namespace nc
{

using mat4 = glm::mat4;
using quat = glm::quat;
using color = glm::vec4;

vec3 normalize(const vec3& vec);
// Normalize vector, if vector cant be normalized return vector with all zeros.
vec3 normalize_or_zero(const vec3& vec);
mat4 look_at(const vec3& pos, const vec3& target, const vec3& up);
mat4 perspective(f32 fov, f32 aspect, f32 near, f32 far);
constexpr vec3 cross(const vec3& vec1, const vec3& vec2);
quat angleAxis(f32 angle, const vec3& vec);
f32 length(const vec2& vec);
f32 length2(const vec2& vec);

mat4 translate(const mat4& matrix, const vec3& vec);
mat4 rotate(const mat4& matrix, f32 angle, const vec3& axis);
mat4 scale(const mat4& matrix, const vec3& vec);

constexpr f32 clamp(f32 x, f32 min, f32 max);
f32 sin(f32 x);
f32 cos(f32 x);
/**
 * Euclidian remained of `value` divided by `range`. Results is always non-negative and lies in the interval
 * [0, range).
 * 
 * It is equivalent to the following mathematical operation: value - range * floor(value / range).
 * 
 * Example usage:
 * f32 result  = rem_euclid( 7.5f, 3.0f); // result  = 1.5f
 * f32 result2 = rem_euclid(-2.0f, 3.0f); // result2 = 1.0f
 */
f32 rem_euclid(f32 value, f32 range);

constexpr vec3 operator*(f32 x, const vec3& vec);
constexpr vec3 operator*(const vec3& vec, f32 x);
constexpr vec3& operator+=(vec3& vec, const vec3& other);
vec3 operator *(const quat& q, const vec3& vec);
vec3 operator *(const vec3& vec, const quat& q);

const f32* value_ptr(const mat4& m);

inline constexpr f32 pi			= glm::pi<f32>();
inline constexpr f32 half_pi	= glm::half_pi<f32>();
inline constexpr f32 quarter_pi = glm::quarter_pi<f32>();

// Definitions of basic colors.
namespace colors
{
  inline constexpr color WHITE  = color(1.00f, 1.00f, 1.00f, 1.0f);
  inline constexpr color BLACK  = color(0.00f, 0.00f, 0.00f, 1.0f);
  inline constexpr color RED    = color(1.00f, 0.00f, 0.00f, 1.0f);
  inline constexpr color GREEN  = color(0.00f, 1.00f, 0.00f, 1.0f);
  inline constexpr color BLUE   = color(0.00f, 0.00f, 1.00f, 1.0f);

  // following colors were generated by deepseek ai

  inline constexpr color YELLOW  = color(1.00f, 1.00f, 0.00f, 1.0f);
  inline constexpr color CYAN    = color(0.00f, 1.00f, 1.00f, 1.0f);
  inline constexpr color MAGENTA = color(1.00f, 0.00f, 1.00f, 1.0f);
  inline constexpr color ORANGE  = color(1.00f, 0.65f, 0.00f, 1.0f);
  inline constexpr color PURPLE  = color(0.50f, 0.00f, 0.50f, 1.0f);
  inline constexpr color PINK    = color(1.00f, 0.75f, 0.80f, 1.0f);
  inline constexpr color GRAY    = color(0.50f, 0.50f, 0.50f, 1.0f);
  inline constexpr color BROWN   = color(0.65f, 0.16f, 0.16f, 1.0f);
  inline constexpr color LIME    = color(0.75f, 1.00f, 0.00f, 1.0f);
  inline constexpr color TEAL    = color(0.00f, 0.50f, 0.50f, 1.0f);
  inline constexpr color NAVY    = color(0.00f, 0.00f, 0.50f, 1.0f);
  inline constexpr color MAROON  = color(0.50f, 0.00f, 0.00f, 1.0f);
  inline constexpr color OLIVE   = color(0.50f, 0.50f, 0.00f, 1.0f);
  inline constexpr color SILVER  = color(0.75f, 0.75f, 0.75f, 1.0f);
  inline constexpr color GOLD    = color(1.00f, 0.84f, 0.00f, 1.0f);
}

}

#include <temp_math.inl>