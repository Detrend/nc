// Project Nucledian Source File
#pragma once

#include <types.h>

// GLM requires these
#include <cmath>
#include <climits>
#include <cfloat>
#include <limits>
#include <cassert>

#define GLM_ENABLE_EXPERIMENTAL
#define GLM_FORCE_ALIGNED_GENTYPES // enables the glm::aligned versions
#define GLM_FORCE_SWIZZLE          // enables us doing GLSL-like swizzling
#include <glm/detail/_fixes.hpp>
#include <glm/detail/setup.hpp>
#include <glm/ext/vector_float2_precision.hpp>
#include <glm/ext/vector_float3_precision.hpp>
#include <glm/ext/vector_float4_precision.hpp>

namespace nc
{

using namespace glm;
  
// Non-aligned vector types. These take up less space, but
// the compiler can't optimize them with SSE instructions
// that easily. Use these if you want to save space or do not
// need performance.
using vec2 = glm::vec<2, f32, glm::packed>;
using vec3 = glm::vec<3, f32, glm::packed>;
using vec4 = glm::vec<4, f32, glm::packed>;

template<typename T, u64 S>
using vec = glm::vec<S, T, glm::packed>;

// Aligned vector types. Compiler can replace the operations of
// these types with SIMD instructions more easily and therefore
// can give a better performance.
// !!!BEWARE!!!
// These can take more space than expected! The vec3 has the same size
// as vec4 (even though it has only 3 components) and the extra space
// is padded out. Therefore, you can't just copy a memory of an array
// of vec3a to GPU.
using vec2a = glm::vec<2, f32, glm::aligned>; // aligned to  8 bytes, takes up  8 bytes
using vec3a = glm::vec<3, f32, glm::aligned>; // aligned to 16 bytes, takes up 16 bytes
using vec4a = glm::vec<4, f32, glm::aligned>; // aligned to 16 bytes, takes up 16 bytes

template<typename T, u64 S>
using veca = glm::vec<S, T, glm::aligned>;

using color4 = vec4;
using color3 = vec3;

// This one is extra because it does not have different SSE/NON-SSE implementation.
// Checks if the vector has length of 1
template<typename T, u64 SIZE>
bool is_normal(const vec<T, SIZE>& v, T threshold = static_cast<T>(0.01));

template<typename T, u64 SIZE>
bool is_zero(const vec<T, SIZE>& v, T threshold = static_cast<T>(0.01));

// Returns a vector rotated 90 degrees to the left
// (flips the components and negates x of the new vector)
vec2 flipped(const vec2& v);

f32 cross(const vec2& a, const vec2& b);

// Normalize vector, if vector cant be normalized return vector with all zeros.
template<typename T>
T normalize_or_zero(const T& vec);

template<typename VT, typename FT>
VT with_x(const VT& v, const FT& x);

template<typename VT, typename FT>
VT with_y(const VT& v, const FT& x);

template<typename VT, typename FT>
VT with_z(const VT& v, const FT& x);

template<typename VT, typename FT>
VT with_w(const VT& v, const FT& x);

constexpr vec3 UP_DIR    = vec3{0, 1,  0};
constexpr vec3 RIGHT_DIR = vec3{1, 0,  0};
constexpr vec3 FRONT_DIR = vec3{0, 0, -1};

constexpr vec2 VEC2_X = vec2{1, 0};
constexpr vec2 VEC2_Y = vec2{0, 1};

constexpr vec3 VEC3_X = vec3{1, 0, 0};
constexpr vec3 VEC3_Y = vec3{0, 1, 0};
constexpr vec3 VEC3_Z = vec3{0, 0, 1};

constexpr vec4 VEC4_X = vec4{1, 0, 0, 0};
constexpr vec4 VEC4_Y = vec4{0, 1, 0, 0};
constexpr vec4 VEC4_Z = vec4{0, 0, 1, 0};
constexpr vec4 VEC4_W = vec4{0, 0, 0, 1};

constexpr vec2 VEC2_ZERO = vec2{0, 0};
constexpr vec3 VEC3_ZERO = vec3{0, 0, 0};
constexpr vec4 VEC4_ZERO = vec4{0, 0, 0, 0};

// Definitions of basic colors.
namespace colors
{
  constexpr color4 WHITE  = color4(1.00f, 1.00f, 1.00f, 1.0f);
  constexpr color4 BLACK  = color4(0.00f, 0.00f, 0.00f, 1.0f);
  constexpr color4 RED    = color4(1.00f, 0.00f, 0.00f, 1.0f);
  constexpr color4 GREEN  = color4(0.00f, 1.00f, 0.00f, 1.0f);
  constexpr color4 BLUE   = color4(0.00f, 0.00f, 1.00f, 1.0f);

  // following colors were generated by deepseek ai

  constexpr color4 YELLOW  = color4(1.00f, 1.00f, 0.00f, 1.0f);
  constexpr color4 CYAN    = color4(0.00f, 1.00f, 1.00f, 1.0f);
  constexpr color4 MAGENTA = color4(1.00f, 0.00f, 1.00f, 1.0f);
  constexpr color4 ORANGE  = color4(1.00f, 0.65f, 0.00f, 1.0f);
  constexpr color4 PURPLE  = color4(0.50f, 0.00f, 0.50f, 1.0f);
  constexpr color4 PINK    = color4(1.00f, 0.75f, 0.80f, 1.0f);
  constexpr color4 GRAY    = color4(0.50f, 0.50f, 0.50f, 1.0f);
  constexpr color4 BROWN   = color4(0.65f, 0.16f, 0.16f, 1.0f);
  constexpr color4 LIME    = color4(0.75f, 1.00f, 0.00f, 1.0f);
  constexpr color4 TEAL    = color4(0.00f, 0.50f, 0.50f, 1.0f);
  constexpr color4 NAVY    = color4(0.00f, 0.00f, 0.50f, 1.0f);
  constexpr color4 MAROON  = color4(0.50f, 0.00f, 0.00f, 1.0f);
  constexpr color4 OLIVE   = color4(0.50f, 0.50f, 0.00f, 1.0f);
  constexpr color4 SILVER  = color4(0.75f, 0.75f, 0.75f, 1.0f);
  constexpr color4 GOLD    = color4(1.00f, 0.84f, 0.00f, 1.0f);
}

}

#include <math/vector.inl>

