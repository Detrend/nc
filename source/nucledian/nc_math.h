// Project Nucledian Source File
#pragma once

// This would help us with SIMD, however, 
//#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES
//#define GLM_FORCE_INTRINSICS
//#define GLM_FORCE_SSE2
#define GLM_ENABLE_EXPERIMENTAL

#include <types.h>

#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/gtc/constants.hpp>

namespace nc
{

using namespace glm;

template<typename T, u64 S>
using vec = ::glm::vec<S, T>;

using color = vec4;

constexpr vec3 UP_DIR    = vec3{0, 1,  0};
constexpr vec3 RIGHT_DIR = vec3{1, 0,  0};
constexpr vec3 FRONT_DIR = vec3{0, 0, -1};

constexpr vec3 VEC3_X = vec3{1, 0, 0};
constexpr vec3 VEC3_Y = vec3{0, 1, 0};
constexpr vec3 VEC3_Z = vec3{0, 0, 1};

// This one is extra because it does not have different SSE/NON-SSE implementation.
// Checks if the vector has length of 1
template<typename T, u64 SIZE>
bool is_normal(const vec<T, SIZE>& v, T threshold = static_cast<T>(0.01));

template<typename T, u64 SIZE>
bool is_zero(const vec<T, SIZE>& v, T threshold = static_cast<T>(0.01));

// Returns a vector rotated 90 degrees to the left
// (flips the components and negates x of the new vector)
vec2 flipped(const vec2& v);

f32 cross(const vec2& a, const vec2& b);

vec3 with_y(const vec3& v, f32 y);

// Normalize vector, if vector cant be normalized return vector with all zeros.
vec3 normalize_or_zero(const vec3& vec);

/**
 * Euclidian remained of `value` divided by `range`. Results is always non-negative and lies in the interval
 * [0, range).
 * 
 * It is equivalent to the following mathematical operation: value - range * floor(value / range).
 * 
 * Example usage:
 * f32 result  = rem_euclid( 7.5f, 3.0f); // result  = 1.5f
 * f32 result2 = rem_euclid(-2.0f, 3.0f); // result2 = 1.0f
 */
f32 rem_euclid(f32 value, f32 range);

// Returns 1.0f if the value is larger than zero.
// Returns -1.0f if the value is smaller than zero.
// Returns 0.0f if the value is equal to zero.
f32 sgn(f32 value);

// Returns true if abs(num) < tolerance
bool is_zero(f32 num, f32 tolerance);

// Converts degrees to radians
f32 deg2rad(f32 degrees);

// Converts radians to degrees
f32 rad2deg(f32 radians);

inline constexpr f32 pi			= glm::pi<f32>();
inline constexpr f32 half_pi	= glm::half_pi<f32>();
inline constexpr f32 quarter_pi = glm::quarter_pi<f32>();

// Definitions of basic colors.
namespace colors
{
  inline constexpr color WHITE  = color(1.00f, 1.00f, 1.00f, 1.0f);
  inline constexpr color BLACK  = color(0.00f, 0.00f, 0.00f, 1.0f);
  inline constexpr color RED    = color(1.00f, 0.00f, 0.00f, 1.0f);
  inline constexpr color GREEN  = color(0.00f, 1.00f, 0.00f, 1.0f);
  inline constexpr color BLUE   = color(0.00f, 0.00f, 1.00f, 1.0f);

  // following colors were generated by deepseek ai

  inline constexpr color YELLOW  = color(1.00f, 1.00f, 0.00f, 1.0f);
  inline constexpr color CYAN    = color(0.00f, 1.00f, 1.00f, 1.0f);
  inline constexpr color MAGENTA = color(1.00f, 0.00f, 1.00f, 1.0f);
  inline constexpr color ORANGE  = color(1.00f, 0.65f, 0.00f, 1.0f);
  inline constexpr color PURPLE  = color(0.50f, 0.00f, 0.50f, 1.0f);
  inline constexpr color PINK    = color(1.00f, 0.75f, 0.80f, 1.0f);
  inline constexpr color GRAY    = color(0.50f, 0.50f, 0.50f, 1.0f);
  inline constexpr color BROWN   = color(0.65f, 0.16f, 0.16f, 1.0f);
  inline constexpr color LIME    = color(0.75f, 1.00f, 0.00f, 1.0f);
  inline constexpr color TEAL    = color(0.00f, 0.50f, 0.50f, 1.0f);
  inline constexpr color NAVY    = color(0.00f, 0.00f, 0.50f, 1.0f);
  inline constexpr color MAROON  = color(0.50f, 0.00f, 0.00f, 1.0f);
  inline constexpr color OLIVE   = color(0.50f, 0.50f, 0.00f, 1.0f);
  inline constexpr color SILVER  = color(0.75f, 0.75f, 0.75f, 1.0f);
  inline constexpr color GOLD    = color(1.00f, 0.84f, 0.00f, 1.0f);
}

}

